# 串
- 定义：串是由零个或多个字符组成的有效序列，一般记作  
S='a<sub>1</sub>a<sub>2</sub>...a<sub>n</sub>'，S是串名，a<sub>i</sub>是字符，n是串的长度
- 子串：串中任意个连续字符组成的子序列
- 数据对象：字符集
- 基本操作：大多以字串为操作对象
- 朴素匹配模式性能分析：
  - 设主串长度为n，模式串长度为m
  - 匹配成功的最好时间复杂度：O(m)
    - 原因：第一个子串就找到了
  - 匹配失败的较好情况时间复杂度：O(n-m+1)=O(n-m)≈O(n)
    - 原因：长度为n的主串共有n-m+1个长度为m的子串，由于这是匹配失败的最好情况，所以每次比对时子串的第一个字符和模式串的就不一样，所以每个子串和模式串只要比较一次，一共需要检查完这n-m+1次，时间复杂度是O(n-m+1)也就是O(n-m)，由于在大多数情况下n远远大于m，所以可以认为时间复杂度约等于O(n)
  - 匹配成功/失败的最坏时间复杂度：O((n-m+1)*m)≈O(nm)
    - 原因：由于是最坏情况，匹配成功需要比对到最后一个子串才成功，匹配失败也要比对所有子串。由于是最坏情况，每个子串都要比对到模式串的最后一个字符，每个子串要比对m次，一共(n-m+1)个子串，一共(n-m+1)*m次。由于n远远大于m，所以化简得到的m-m<sup>2</sup>都可以省去，时间复杂度约等于O(nm)
- KMP算法：
  - 当遇到子串和模式串不匹配时，主串不回溯，模式串从j回溯到next[j]
  - 优点：充分利用已经比对过的模式串信息，可以提高比对效率
  - 优化：nextval数组
- KMP算法性能分析： 
  - 设主串长度为n，模式串长度为m
  - 平均时间复杂度：O(n+m)
    - 原因：求next数组时间复杂度为O(m)，不回溯地遍历主串时间复杂度为O(n)
- 常考题型：
  - 手算法求模式串的next数组：
    - 前缀：包含第一个字符，且不包含最后一个字符的子串
    - 后缀：包含最后一个字符，且不包含第一个字符的子串
    - 求next数组：设模式串在第j个位置匹配失败，第1~j-1个字符组成的子串为S：  
      - next[j]=S的最长相同前后缀长度+1
        - 特别地，next[1]=0
        - 一般地，next[2]=1
  - 手算法求模式串的nextval数组：
    - 先求出next数组
    - 先令nextval[1]=0
    - 用变量j从左往右遍历模式串
      - 如果j对应的字符和next[j]对应的字符相同，那么让nextval[j]=nextval[next[j]]
      - 如果j对应的字符和next[j]对应的字符不同，那么让nextval[j]=next[j]