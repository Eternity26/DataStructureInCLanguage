# 查找
- 基本概念：
  - 查找表：进行查找的数据集合
    - 静态查找表：只进行查找
    - 动态查找表：进行查找和增删
  - 关键字：数据项的唯一标识
  - 评价查找效率标准：ASL，平均查找长度，查找成功和失败都要考虑
- 顺序查找：
  - 直接从头到尾或者从尾到头找
  - 时间复杂度：O(n)
  - 适用范围：顺序表/链表
  - 优化，使不用判断越界：可以在0号位置存一个哨兵
    - ``int search(SqList list,int key){``
    - ``list.data[0] = key; ``
    - ``int i;``
    - ``for(i=list.length-1;list.data[i]!=key;i--);``
    - ``return i;``
    - ``}``
  - 对有序表的优化：当前关键字大于(或小于)被查关键字时，查找失败
    - 可使查找失败ASL更少
    - 对应查找判定树：![SearchJudgementTree](SearchJudgementTree.jpg)
  - 对关键字被查概率不同的表的优化：按被查概率降序排列
    - 可使查找成功ASL更少
- 折半查找：
  - 过程：
    - 开始时，low=0，high=list.length-1，mid=(low+high)/2
    - 如果list.data[mid]<key，low=mid+1，mid=(low+high)/2
    - 如果list.data[mid]>key，high=mid-1，mid=(low+high)/2
    - 如果list.data[mid]==key，查找成功
    - 如果low>high，查找失败
  - 时间复杂度：O(log<sub>2</sub>n)
  - 适用范围：有序的顺序表
  - 折半查找判定树：
    - 构造：以mid作为父结点，mid左边作为左子树，mid右边作为右子树
      - 右子树结点数-左子树结点数=0或1
      - ![](BinarySearchJudgementTree1.jpg)
      - ![](BinarySearchJudgementTree2.jpg)
      - ![](BinarySearchJudgementTree3.jpg)
    - 特性：
      1. 是平衡的二叉排序树，左<中<右
      2. 只有最下面一层不满(不含失败结点)
      3. 如果查找表有n个关键字，则失败结点有n+1个
      4. 树高h=⌈log<sub>2</sub>(n+1)⌉，不含失败结点
- 分块查找：
  - 把表元素按照范围分为若干块，用索引表存储每个块中关键字最大值，先根据索引表找到关键字所在块，再在块中查找
  - ![](Screenshot_20211024_161042_tv.danmaku.bili.jpg)
  - ![](Screenshot_20211024_161144_tv.danmaku.bili.jpg)
  - ![](Screenshot_20211024_161345_tv.danmaku.bili.jpg)
  - ![](Screenshot_20211024_161416_tv.danmaku.bili.jpg)
  - ![](Screenshot_20211024_161454_tv.danmaku.bili.jpg)
- 散列查找：
  - 散列表：关键字与存储地址有Addr=H(key)的函数关系
  - 同义词：通过函数映射到同一个地址的不同关键字
  - 冲突：通过函数确定的位置已有其他元素。冲突越多查找效率越低
    - 解决：
      1. 拉链法/链接法/链地址法：把所有同义词储存在链表中
          - 特殊情况：碰到查找的关键字映射之后的地址没有元素时查找长度为0![](Hash.png)
            - 有的教材把空指针也算一次比较![](Hash1.png)
      2. 开放定址法：空闲地址既向同义词开放也向非同义词开放![](a.png)
          - 设计增量序列d<sub>i</sub>的办法：
            1. 线性探测法(重点)：检查发生冲突的地址的下一个地址空不空闲![](b.png)
                - 查找成功计算查找长度：![](c.png)
                - 查找失败计算查找长度：![](d.png)
                  - 注意：最后比较空位置也算一次比较次数。原因：由于用了开放定址法所有元素都可以看成地位平等的关键字，而不像拉链法一样将空元素看成空指针
                - 缺点：同义词、非同义词聚集，影响查找效率![](e.png)
                - 注意：采用开放定址法是删除结点不能把结点空间置空，只能做删除标记。例如此处删除地址为2的元素就在上面标记，在查找时遇到这个地址为2的位置的时候不判定为查找失败，接着往下找![](f.png)否则如果把空间置空，那么将会出现已经碰到空位置判定查找失败，但是空位置之后可能就有要找的关键字的情况。例如这里删除1，如果置空，就直接在地址为2的地方检测到空位置停止判断，但是之后明明有要找的27没被查找过![](g.png)
                - 计算查找成功的平均查找长度：![](h.png)
                - 计算查找失败的平均查找长度：![](i.png)
            2. 平方探测法/二次探测法(重点)：![](j.png)此处放32进去，H<sub>0</sub>=(32+0)/13=6，6号地址有元素，发生第一次冲突，H<sub>1</sub>=(32+1^2)/13=7，7号地址有元素，发生第二次冲突，H<sub>2</sub>=(32+(-1^2))/13=5，5号是空位置，把32放进去![](k.png)此处放84进去，发生6次冲突后，d<sub>6</sub>=-9，要在在6号地址往左移9格，左边移6格到头了再从尾部往左移3格
                - 比线性探测法更不易产生聚集
                - 散列表长度m是可表示为4j+3的素数时才可探测到所有位置![](l.png)此处如果表长为8探测的位置会一直重复
            3. 伪随机序列法：![](m.png)
      3. 再散列法：![](n.png)
  - 装填因子α：散列查找的平均失败查找长度，=记录数/散列表长度![](Hash2.png)
    - 直接影响散列查找效率
  - 常见的散列函数：
    1. 除留余数法：![](1.png)
    2. 直接定址法：![](2.png)
    3. 数字分析法：![](3.png)
    4. 平方取中法：![](4.png)
  - 特点：用空间换时间，效率取决于散列函数、处理冲突的办法、装填因子α
  - 拉链法的优化：![](o.png)