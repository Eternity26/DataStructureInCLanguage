# 树

- 概念：
    - 空树：结点数为0的树
    - 非空树的特性：
        1. 有且仅有一个根结点
        2. 没有后继的结点称为叶子结点
        3. 有后继的结点称为分支节点
        4. 除根结点外，每个结点有且仅有一个前驱
        5. 每个结点可以有0个或多个后继

        - 每个结点可以有包含空树在内的任意个子树，每个子树互不相交
    - 祖先结点、子孙结点、双亲结点、孩子结点、兄弟结点、堂兄弟结点
    - 路径是单向的，从祖先到子孙
    - 路径长度：经过了几条边
    - 属性：
        - 结点的层次(深度)：从上往下数
            - 默认从1开始，题目也可能从0开始
        - 结点的高度：从下往上数
        - 树的高度(深度)：总共多少层
        - 结点的度：有几个孩子
        - 树的度：各结点度的最大值
    - 有序树：各结点从左到右的子树是有次序的
    - 无序树：各结点从左到右的子树是无次序的
    - 森林：若干互不相交的树的集合
        - 常考题型：森林和树的转换
    - 空森林：0棵树的集合
- 树的常考性质：
    1. 结点数=各结点总度数+1
    2. 度为m的树和m叉树的区别：
        - 由于树的度数指的是度数最多的结点的度数，所以度为m的树表示的是树中必须至少有一个度为3的结点，且不能为空树；m叉树表示的是树中的结点最大为m，可以所有结点的度数都小于3，甚至可以是m叉空树
    3. 度为m的树/m叉树第i层至多有m<sup>i-1</sup>个结点，i>=1
        - 原因：结点最多的情况是除了最后一层的结点，每个结点都有m个孩子
    4. 高度为h的m叉树/度为m的树至多有(m<sup>h</sup>-1)/(m-1)个结点
        - 原因：结点最多的情况同iii，此时将每一层的结点加起来，也就是等比数列求和，首项为1，公比为m，项数为h
    5. 高度为h的度为m的树至少有h-1+m个结点，高度为h的m叉树至少有h个结点
        - 原因：由于要保证至少一个结点的度为m，所以度为m的树结点最少的情况是高度为1的这一层有m个结点，其余所有层都只有一个结点；m叉树不用保证至少有一个结点度数为m，所以每一层都只有一个结点
    6. 具有n个结点的m叉树/度为m的树最小高度为⌈log<sub>m</sub>(n(m-1)+1)⌉
        - 原因：
          - 给定了结点数，要保证高度最小，则要保证每一层要有最多的结点
          - 由iv可知，高度为h的m叉树至多有(m<sup>h</sup>-1)/(m-1)个结点
          - 所以(m<sup>h-1</sup>-1)/(m-1)<n<=(m<sup>h</sup>-1)/(m-1)，即这个数的结点数n必须大于高度为h-1的结点数最多的m叉树，以使这棵树的高度达到h；但是又不能超过高度为h的结点数最多的m叉树，防止高度达到h+1
          - 一系列化简，得h-1<log<sub>m</sub>(n(m-1)+1)<=h
          - 中间式子向上取整，得h=⌈log<sub>m</sub>(n(m-1)+1)⌉
- 树的存储方式：
  1. 双亲表示法(顺序存储)：
    - 每个结点除了保存自身数据，还保存指向双亲的下标，将结点存入一个一维数组
      - 根结点保存的值为-1
    - 增：直接在数组末尾添加新结点
    - 删：
      - 如果是叶子结点，有两种方案：
        1. 直接令下标值为-1，清空数据
           - 缺点：会造成该位置没有实际数据，浪费了空间，进行查询等需要遍历的操作会变慢
        2. 将最后一个结点放入该被删除结点的位置
      - 如果是分支结点，不仅删除它自身还要删除它的全部后代
    - 查：查找双亲直接访问存储的双亲下标，查找孩子要从数组的第一个元素开始遍历
  2. 孩子表示法(顺序+链式存储)：
    - 将每个结点保存进一个一维数组。每个结点除了保存自身数据，还保存一个指向自己的孩子链表的第一个结点(第一个孩子)的指针，孩子链表的每个结点保存了孩子的数组下标和指向下一个孩子的指针
  3. (最重要)孩子兄弟表示法(链式存储)：
    - 每个结点保存firstchild指针指向第一个孩子(可看做二叉树的lchild)，nextsibling指向右兄弟(可看作二叉树的rchild)
    - 利用这种表示法可以完成：
      1. 树和二叉树的转换：firstchild和lchild转换，nextsibling和rchild转换
      2. 森林转(二叉)树：
         - 可以将森林里每个树的根结点看成是兄弟关系，用nextsibling指针连起来
      3. (二叉)树转森林：
         - 从根结点开始，将(二叉)树最右链的所有边断掉，直到结点没有右孩子
- 树/森林的遍历：
  - 树：
    1. 先根遍历(深度优先遍历)：若树非空，先访问根结点，再先根遍历每个子树，顺序与二叉树的先序遍历序列相同
    ```c++
    void PreOrder(Tree t){
        if(t!=NULL){
            visit(t);
            while(t还有下一个子树r){
                PreOrder(r);
            }
        }
    }
    ```
    2. 后根遍历(深度优先遍历)：若树非空，先后根遍历每个子树，再访问根结点，顺序与二叉树的中序遍历序列相同
    ```c++
    void PostOrder(Tree t){
        if(t!=NULL){
            while(t还有下一个子树r){
                PostOrder(r);
            }
            visit(t);
        }
    }
    ```
    3. 层次遍历(广度优先遍历)：将根结点放入辅助队列中，此后重复执行取出队头元素进行处理并让队头元素的孩子入队的操作直到队空
  - 森林：
    1. 先序遍历：
       - 依次对森林里的每棵树进行先序遍历
       - 也可将森林转化成二叉树后对二叉树进行先序遍历，因为二者序列相同
    2. 中序遍历：
       - 依次对森林里的每棵树进行后根遍历
       - 也可将森林转化成二叉树后对二叉树进行中序遍历，因为二者序列相同
  - 对应关系：
    - 树的先根遍历=森林的先序遍历=二叉树的先序遍历
    - 树的后根遍历=森林的中序遍历=二叉树的中序遍历
