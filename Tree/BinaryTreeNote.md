# 二叉树

- 定义：个数为n的结点的集合，其中每个结点要么是空树，要么有一棵左子树或者右子树或者都有或者都没有
- 二叉树左右子树有次序差别，是有序树
- 几种特殊的二叉树：
    - 满二叉树：除最后一层的结点外，所有结点都有左右子树
        - 若高度为h，则共有2<sup>h</sup>-1个结点
            - 原因：第一层有2<sup>0</sup>个结点，第二层有2<sup>1</sup>个结点...第h层有2<sup>h-1</sup>个结点，等比数列求和得2<sup>h</sup>-1个结点
        - 特点：
            1. 只有最后一层是叶子结点
            2. 没有度为1的结点
            3. 按层序为1从左到右、从上到下进行编号，编号为i的结点左子结点编号为2i，右子结点编号为2i+1，父节点编号为⌊i/2⌋(⌊⌋为向下取整)(除根结点)
    - 完全二叉树：
        - 所有结点满足跟满二叉树的前n个结点编号一一对应的二叉树
        - 即从满二叉树的末尾开始删除0(即为满二叉树，满二叉树是一种特殊的完全二叉树)或若干个结点得来(不从末尾删除会打乱编号)
        - 特点：
            1. 只有最后两层可能出现叶子结点
            2. (重点)最多只有一个度为1的结点(有两个或以上会打乱编号，且这个结点孩子只能为左孩子)
            3. 按层序为1从左到右、从上到下进行编号，编号为i的结点左子结点编号为2i，右子结点编号为2i+1，父节点编号为⌊i/2⌋(⌊⌋为向下取整)(除根结点)
            4. i<=⌊n/2⌋为分支结点，i>⌊n/2⌋为叶子结点(⌊⌋为向下取整)
    - 二叉排序树：
        - 空二叉树，或者所有结点均满足：左子树的关键字小于根结点的关键字，且右子树的关键字大于根结点的关键字的二叉树；每个左子树/右子树又是一棵二叉排序树
        - 便于排序和搜索
    - 平衡二叉树：
        - 除叶子结点外，所有结点左子树和右子树的深度之差不超过1
        - 有更高的搜索效率(让树高度更低)
- 常考性质：
    1. (重点)设二叉树中度数为0,1,2的结点数分别为n<sub>0</sub>,n<sub>1</sub>,n<sub>2</sub>，那么n<sub>0</sub>=n<sub>2</sub>+1

    - 原因：设树的总结点数为n，
    - I.n=n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>
    - II.n=n<sub>1</sub>+2n<sub>2</sub>+1
        - 原因：树的总结点数=各结点总度数+1
    - II-I，即得n<sub>0</sub>=n<sub>2</sub>+1

    2. 二叉树第i层至多有2<sup>i-1</sup>个结点(i>=1)
    3. 高度为h的二叉树至多有2<sup>h</sup>-1个结点(即为满二叉树)
- 常考考点：
    1. 具有n(n>0)个结点的完全二叉树的高度为⌈log<sub>2</sub>(n+1)⌉(⌈⌉为向上取整)或⌊log<sub>2</sub>n⌋+1(⌊⌋为向下取整)
        - 原因：
            - 得到⌈log<sub>2</sub>(n+1)⌉:
                - 由于高度为h的满二叉树结点树为2<sup>h</sup>-1，所以设该完全二叉树高度为h，则2<sup>h-1</sup>-1<n<=2<sup>h</sup>
                  -1，即这个数的结点数n必须大于高度为h-1的结点数最多的二叉树，以使这棵树的高度达到h；但是又不能超过高度为h的结点数最多的二叉树，防止高度达到h+1
                - 一系列化简，得h-1<log<sub>2</sub>(n+1)<=h
                - 中间式子向上取整，得h=⌈log<sub>2</sub>(n+1)⌉
            - 得到⌊log<sub>2</sub>n⌋+1:
                - 由于高度为h-1的满二叉树结点树为2<sup>h-1</sup>-1，所以对该高度为h的完全二叉树，它至少要比高度为h-1的满二叉树多一个结点，也就是至少有2<sup>h-1</sup>
                  个结点，但必须少于2<sup>h</sup>个结点，否则高度将到达h+1，即不等式为2<sup>h-1</sup><=n<2<sup>h</sup>
                - 一系列化简，得h-1<=log<sub>2</sub>n<h
                - 中间式子向下取整，得h=⌊log<sub>2</sub>n⌋+1
        - 在完全二叉树中，第i个结点也满足高度为⌈log<sub>2</sub>(i+1)⌉(⌈⌉为向上取整)或⌊log<sub>2</sub>i⌋+1(⌊⌋为向下取整)
    2. 对于完全二叉树，设度数为0,1,2的结点数分别为n<sub>0</sub>,n<sub>1</sub>,n<sub>2</sub>，则：
        1. n<sub>1</sub>为0或1
        2. n<sub>0</sub>=n<sub>2</sub>+1，所以n<sub>0</sub>+n<sub>2</sub>一定为奇数
            - 因此，如果完全二叉树的结点数为2k(k为正整数)，即为偶数，那么可以推出n<sub>0</sub>=k，n<sub>1</sub>=1，n<sub>2</sub>=k-1
                - 原因：因为n<sub>0</sub>+n<sub>2</sub>一定为奇数，所以要保证结点数2k是个偶数，所以n<sub>1</sub>必定是奇数，才能保证奇+奇=偶，去掉了n<sub>1</sub>
                  后，结点数还剩2k-1，由于n<sub>0</sub>=n<sub>2</sub>+1，所以可以推出n<sub>0</sub>=k，n<sub>2</sub>=k-1
            - 同理，如果完全二叉树的结点数为2k-1(k为正整数)，即为奇数，那么可以推出n<sub>0</sub>=k，n<sub>1</sub>=0，n<sub>2</sub>=k-1
- 存储结构：
    1. 顺序存储：
        - 存储方式：每个结点包含数据域和isEmpty字段，将二叉树的结点按照编号存储进数组，并最好将数组的下标0位置空出以保证用于储存结点的下标和编号相同
        - 常用操作，设已知结点编号为i：
            1. 左孩子为2i
            2. 右孩子为2i+1
            3. 父结点为⌊i/2⌋
        - 注意：已知树结点数为n，判断有无左孩子/右孩子/父结点：
            1. 如果是完全二叉树：判断2i是否<=n / 2i+1是否<=n / i是否为1
                - 原因：由于完全二叉树的已用结点编号是连续的，中间没有空缺，所以判断有无孩子只要判断假定孩子的编号是否溢出总结点数，判断有无父结点只要判断它是不是根结点
            2. 如果是非完全二叉树：判断2i/2i+1/⌊i/2⌋的isEmpty属性是否为true
        - 顺序存储只适合存储完全二叉树
            - 原因：最坏情况：当每个结点都只有右孩子时，会造成大量的位置空缺，且如果树高h，仍然需要2<sup>h-1</sup>个结点大小的存储空间
    2. 链式存储(二叉链表)：
        - 存储方式：每个结点包含数据域和指向左孩子和右孩子的指针
        - 设结点数为n，二叉链表一共有n+1个空链域，可以用来构造线索二叉树
            - 原因：每个结点有2个已用或未用的指针，所以一共有2n个指针，又因为除了根结点外，每个结点头上都有一个已用的指针，这样的指针数量为n-1，2n-(n-1)=n+1，即未用的空指针
        - 找到指定结点的孩子结点：直接访问节点中lchild和rchild指针
        - 找到指定结点的父结点：只能从根节点开始遍历
            - 为了方便查找父结点，可以让二叉链表变成三叉链表，即给每个结点加上指向父结点的parent指针
- 先/中/后/序(根)遍历：
    - 先序遍历：根左右
    - 中序遍历：左根右
    - 后序遍历：左右根
    - 设二叉树高h，时间复杂度为O(h)
    - 常考考点： 给定二叉树，手算遍历顺序
        - 手算方法：
            - 若二叉树为空，什么也不做
            - 若二叉树非空：
                - 从根结点出发，如果左边还没走，优先往左走
                - 碰到尽头(即空结点)则往回走
                - 左边没路了往右走
                - 左右都没路了往上走

                1. 对于先序遍历，在第一次路过结点的时候执行操作
                2. 对于中序遍历，在第二次路过结点的时候执行操作
                3. 对于后序遍历，在第三次路过结点的时候执行操作

            - 补充：算术表达式的分析树：
                - 先序遍历：得到前缀表达式
                - 中序遍历：得到中缀表达式(不含界限符)
                - 后序遍历：得到后缀表达式
    - 应用：求二叉树深度
- 二叉树的层序遍历
  - 步骤：
    1. 初始化一个辅助队列
    2. 让根结点入队
    3. 如果队列非空，让队头结点出队并处理该结点，让左右孩子入队
    4. 重复3直到队列为空
- 由遍历序列手算推出二叉树：
  - 单独的先/中/后序或层序遍历不能推出二叉树形态
  - 要推出二叉树形态，需要：
    1. 先序+中序
    2. 后序+中序
    3. 层序+中序
    - 利用根结点的唯一性，通过先序/后序/层序确定根结点位置，然后再确定左右子树，再确定左右子树的根结点...
    - 先序对应：根结点+左子树的先序序列+右子树的先序序列
    - 中序对应：左子树的中序序列+根结点+右子树的中序序列
    - 后序对应：左子树的后序序列+右子树的后序序列+根结点
    - 层序对应：根结点+左子树的根+右子树的根
- 线索二叉树(线索链表)
  - 线索二叉树的优点：
    1. 遍历可以从任意结点开始
    2. 找指定遍历方式的前驱/后继结点方便
  - 线索：对于前/中/后/层序遍历的方式，将指向这种方式对应的前驱/后继结点的指针称为前驱/后继线索
    - e.g. 对于中序遍历有序列ABCDEF，那么A的前驱线索是null，A的后继线索是指向B的指针
  - 线索二叉树：将没有左孩子/右孩子的结点的lchild/rchild指针(即空链域)设为指向中序遍历序列的前驱/后继结点，并用ltag/rtag变量标记该结点是否有左/右孩子，0表示有，那么指针指向孩子；1表示无，那么指针是线索
  - 考点：
    1. 给定指定方式的遍历序列，手算画出线索二叉树
    2. 机算将二叉树线索化